<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://mzampetakis.com/</id><title>Michalis Zampetakis</title><subtitle>This is Michalis Zampetakis's personal web page and blog.</subtitle> <updated>2023-03-17T04:19:56+08:00</updated> <author> <name>Michalis Zampetakis</name> <uri>https://mzampetakis.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://mzampetakis.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://mzampetakis.com/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2023 Michalis Zampetakis </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Testing 101</title><link href="https://mzampetakis.com/posts/Testing-101/" rel="alternate" type="text/html" title="Testing 101" /><published>2022-11-09T03:30:00+08:00</published> <updated>2022-11-09T03:30:00+08:00</updated> <id>https://mzampetakis.com/posts/Testing-101/</id> <content src="https://mzampetakis.com/posts/Testing-101/" /> <author> <name>Michalis Zampetakis</name> </author> <summary> What is software testing Software testing is the act of examining the artifacts and the behavior of the software under test by validation and verification. Although software testing can determine the correctness of software under the assumption of some specific hypotheses, testing cannot identify all the failures within the software. The process of testing (software) can be manual or automa... </summary> </entry> <entry><title>Embedding VCS Info in Go binary</title><link href="https://mzampetakis.com/posts/Embedding-VCS-Info-in-Binary/" rel="alternate" type="text/html" title="Embedding VCS Info in Go binary" /><published>2022-01-16T18:15:00+08:00</published> <updated>2022-04-11T04:06:20+08:00</updated> <id>https://mzampetakis.com/posts/Embedding-VCS-Info-in-Binary/</id> <content src="https://mzampetakis.com/posts/Embedding-VCS-Info-in-Binary/" /> <author> <name>Michalis Zampetakis</name> </author> <summary> Binaries we produce from our applications are something like black boxes! When we create and distribute Go binaries we cannon distinguish somehow the version of the binary or any other metadata. Unless we deliberately add appropriate code and update it on every single build we make we cannot offer this capability. It makes sense that when we want to be able to identify different versions of o... </summary> </entry> <entry><title>Testing the Tests</title><link href="https://mzampetakis.com/posts/Testing-the-Tests/" rel="alternate" type="text/html" title="Testing the Tests" /><published>2021-09-11T02:15:00+08:00</published> <updated>2022-03-20T02:50:32+08:00</updated> <id>https://mzampetakis.com/posts/Testing-the-Tests/</id> <content src="https://mzampetakis.com/posts/Testing-the-Tests/" /> <author> <name>Michalis Zampetakis</name> </author> <summary> If we use tests to test code, how can we test our tests? We write tests in order to assure the quality of the software we are writing. Software developers are usually trying to reach a certain level of code coverage through their tests. However, the quality of the tests is not usually measured or examined through this process. It is possible that someone could achieve a 100% code coverage ev... </summary> </entry> <entry><title>Exec.Command</title><link href="https://mzampetakis.com/posts/Exec-Command/" rel="alternate" type="text/html" title="Exec.Command" /><published>2021-05-07T00:40:00+08:00</published> <updated>2022-03-20T02:50:32+08:00</updated> <id>https://mzampetakis.com/posts/Exec-Command/</id> <content src="https://mzampetakis.com/posts/Exec-Command/" /> <author> <name>Michalis Zampetakis</name> </author> <summary> One of the key features of Go is the considerably rich standard library. Go’s os package offers a wide range of methods and functions to allow programmers to exploit the host’s OS capabilities. Using it leaves us with almost no need to invoke system commands. However, we need sometimes to execute a custom bash script or a system command not supported by some library or just invoke a 3rd par... </summary> </entry> <entry><title>Deep Dive in Go Channels</title><link href="https://mzampetakis.com/posts/Deep-Dive-in-Go-Channels/" rel="alternate" type="text/html" title="Deep Dive in Go Channels" /><published>2020-10-31T13:55:00+08:00</published> <updated>2022-03-20T02:50:32+08:00</updated> <id>https://mzampetakis.com/posts/Deep-Dive-in-Go-Channels/</id> <content src="https://mzampetakis.com/posts/Deep-Dive-in-Go-Channels/" /> <author> <name>Michalis Zampetakis</name> </author> <summary> One of the biggest advantages of Go is undoubtedly it’s concurrency management. Goroutines are the main feature that Go uses to achieve this. Goroutines wouldn’t be so easy if there wasn’t for channels. A goroutine is a lightweight thread managed by the Go runtime. Channels are the pipes that connect concurrent goroutines. You can send values into channels from one goroutine and receive t... </summary> </entry> </feed>
